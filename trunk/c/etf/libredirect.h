/** \file libredirect.h
    \brief Implementation interface (private) of Redirection Library.
*/

/*! \mainpage DDL Framework & Redirection Library implementation Documentation
    \section intro_sec Introduction
    DDL framework is an event driven framework for developing tools which
    monitor and/or intercept dynamic linking of function calls in an
    application. Fundamentally, in DDL, an event is nothing but a dynamic
    link request generated by application. DDL framework makes it easy for
    tool developers to 'listen' to dynamic link resolution events and
    'redirect' function calls to different symbols using infrastructure
    libraries such as, Redirection Library. Moreover, DDL-Framework provides
    esoteric features such as table-based redirection and TCL script
    wrappers. This allows more than one link requests getting redirected
    to a single tracing wrapper function and it could invoke a TCL script
    to perform its work!

    \section implementation_sec Implementation of DDL Framework
    \subsection step1 1: Event Dispatcher
        \li eventdispatch.h define Event Dispather service API.
        \li libeventdispatch.h defines implementation interface.
        \li eventdispatch.c implements Event Dispatcher.
    \subsection step2 2: Redirection Library
        \li redirect.h defines Redirection Library service API
        \li libredirect.h defines implementation interface of Redirection Library
        \li redirect.c implements Redirection Library
    \subsection step3 3: LinkDef Library
        \li linkdef.h defines LinkDef Library API
        \li linkdef.c implements LinkDef Library
    \subsection step4 4: HashTable Library
        \li hash.h defines HashTable Library API
        \li hash.c implements HashTable Library
    \subsection step5 5: List Library
        \li list.h defines List Library API
        \li list.c implements List Library
    \subsection step6 6: Table-based redirection
        \li table.h defines implementation interface of table.

    \htmlinclude footer.html
*/


#ifndef __LIBREDIRECT_H
#define __LIBREDIRECT_H

#include "redirect.h"
#include "registrar.h"
#include "eventdispatch.h"

//! \b Callback function of redirection library to intialise internal data structures.
/*! DDL Framework views redirection library as a tool, albeit a special
    tool known as 'master' tool. This function is invoked by DDL framework
    to give master tool a chance to initialise itself. A symbol having
    exactly same prototype must be exported by every master tool.
    So does the redirection library.
\param handle An opaque handle passed by DDL Framework to maintain
              its own data structures for the master tool.
\return A pointer to an instance of master's main data structure.
        DDL Framework allows master tool to pass an instance of master's
        main data structure to slave tools. All slave tools receive same
        pointer as a second parameter during initialisation. This should be
        useful when tools are dependent on master tool's data structure.
\sa tool_init(), _fini()
*/
void *mastertool_init(Registrar *r, int handle, int thread_id);

//! \b Callback function of redirection library for \e RD_IsActiveHook of DDL Framework.
/*! Redirection library determines which callback functions it is interested in
    at runtime using this function.
\param e The next callback event to be produced by DDL Framework.
\return One when it is interested in receiving next callback event notification.
        Zero otherwise.
\sa redirect_lookup(), redirect_offset(), redirect_definition(), redirect_symdef()
*/
int redirect_isactive(EventType e, int thread_id);

//! \b Callback function of redirection library for \e RD_LookupHook of DDL Framework.
/*! Redirection library gets a chance of redirecting a symbol to different symbol
    through this callback function. Redirection library also maintains its own
    internal \e LinkDef data structure inside this function.
\param funcname The function symbol dynamic linker is resolving right now.
\param filename The library (shared object) which is calling \e funcname function.
                and therefore, wants the symbol to be resolved.
\param lookup_libname An out parameter pointing to a library name to force the
                      dynamic linker to search the symbol.
\return Pointer to the symbol which actually gets resolved. If this symbol is different
        than the parameter \e funcname, we say redirection has been done.
\sa redirect_isactive(), redirect_offset(), redirect_definition(), redirect_symdef()
*/
char* redirect_lookup(char* funcname,char *filename,char **lookup_libname, int thread_id);

//! \b Callback function of redirection library for \e RD_OffsetHook of DDL Framework.
/*! Redirection library gets a chance of adding an offset into address of resolved
    symbol through this callback function. This is particularly useful for table based
    redirection functionality.
\param funcname The function symbol dynamic linker resolved right now.
\param libname The library (shared object) which is calling \e funcname function.
                and therefore, wants the symbol to be resolved.
\return An integer value of offset to be added in the symbol address (if at all)
        Zero otherwise.
\sa redirect_isactive(), redirect_lookup(), redirect_definition(), redirect_symdef()
*/
int   redirect_offset(const char *funcname, const char *libname, int thread_id);

//! \b Callback function of redirection library for \e RD_SymdefHook of DDL Framework.
/*! Redirection library gets a chance of 'watching' the symbols getting resolved at
    global scope. Redirection library takes no action in this callback.
\param symbol The symbol dynamic linker is resolving right now. (elf\\rtld.c)
\param libname Unused.
\param address Unused.
\param caller_libname Unused.
\return Returns 1 if no error occured. Unused.
\sa redirect_isactive(), redirect_lookup(), redirect_definition(), redirect_offset()
*/
int   redirect_symdef(const char *symbol, const char *libname,
                      unsigned *address, const char* caller_libname, int thread_id);

//! \b Callback function of redirection library for \e RD_DefinitionHook of DDL Framework.
/*! Redirection library can read the address of the symbol which dynamic linker
    resolved and the GOT entry of the caller library to be updated with this
    address through this callback function. Symbol name, caller library name,
    resolved symbol name and library containing definition of resolved symbol is
    also passed though this callback.
\param new_funcname The symbol actually resolved by dynamic linker.
\param new_libname The library containing definition of symbol.
\param new_func_address Address of definition of resolved symbol.
\param orig_funcname The symbol dynamic linker started to resolve at the beginning.
                     \e redirect_lookup function changes this symbol to
                     different one to achive redirection.
\param orig_libname The library (shared object) which is calling \e funcname function.
                and therefore, wants the symbol to be resolved.
\param orig_func_GOT_addr The address of GOT entry of \ orig_libname to be
       updated with the address of symbol resolved by dynamic linker.
\return Returns one if function finished successfully. Zero otherwise. Unused.
\sa redirect_isactive(), redirect_lookup(), redirect_offset(), redirect_symdef()
*/
int redirect_definition(const char *new_funcname,
                        const char *new_libname,
                        const unsigned *new_func_address,
                        const char *orig_funcname,
                        const char *orig_libname,
                        const unsigned *orig_func_GOT_addr,
                        int thread_id);

//! Internal function to enter link and definition entries into LinkDef data structure.
/*! This is an internal function used by \e redirect_symtosym() and \e
    redirect_symtotable(). It makes an entry for link and def into LinkDef
    data structure if no already present. This function does not no update
    the GOT entry by itself, it only makes an entry for possible future
    redirection. See \e redirect_commit() for more information.
\param linkdef A pointer to LinkDef data structure.
\param link_funcname The function symbol representing link.
\param caller_libname The library trying to call the function represented by
                      the symbol \e linkfuncname
\param def_funcname The definition symbol where you want the link to point at.
\param def_libname The library which holds the definition of symbol
                   pointed by by \e def_funcname.
\param tabledef If definition is a table, you may pass pointer to the it
                to avoid name lookup for the difinition.
\return Returns pointer to Link found/added in the LinkDef data structure.
\sa redirect_commit(), redirect_symtosym(), redirect_symtotable()
*/
ListElement *redirect_linktodef(LinkDef *linkdef,
                                const char *link_funcname,
                                const char *caller_libname,
                                const char *def_funcname,
                                const char *def_libname,
                                ListElement *tabledef);

//! Internal function to update GOT entry of enter corresponding to link if possible.
/*! This function attempts to update the GOT entry of \e link and makes it
    point to the address of definition given by \e def. It can't guarantee
    the operation when the \e link has not been resolved ever before. It means
    redirection library does not know the GOT entry to of the link. But
    redirection will take place when the dynamic linker tries to resolve the
    link. It accepts any two arbitrary \e link and \e def pointers. Using
    this function directly without going through redirect_symtosym() and/or
    redirect_symtotable() can be dangerous. State of LinkDef data structure
    must be maintained before you call this function.
\param link A pointer to link you want to redirect to def.
\param def A pointer to def the link will be redirected to.
\return Returns pointer to Link found/added in the LinkDef data structure.
\sa redirect_symtosym(), redirect_symtotable(), redirect_linktodef()
*/
ListElement *redirect_commit(ListElement *link, ListElement *def);

//! Internal function to print a \e ListElement.
/*! This function prints link or definition node conents given
    a pointer to it.
\param element A pointer to either a link or a definition.
*/
void redirect_show(const ListElement *element);

//! \b Callback internal function to handle signal USR2.
/*! Redirection library supports another way of input through operating system
    signal : SIGUSR2. When received this signal, control reaches in this function,
    it reads the file pointed by LD_REDIRECT environmental variable which is
    also used to during initialisation of redirection library. It takes actions
    as per given in the file. This function is the entry point of all this mechanism.
\param sig Signal number. See man pages for system call signal.
\return Nothing
\sa specfile_read()
*/
void redirect_signal_handler(int sig);

//! Abstracts process of obtaining table offset.
/*! This function obtains table offset for a function to be added
    in a table defined in \e table_libname. It calls \e _jt_get_tableoffset
    defined in \e table_libname. If more than one tables are present
    then you might need to use dlopen and dlsym.
\param funcname The function to be added to the table.
\param caller_libname Caller library name.
\param table_libname The library in which table is defined.
\return table offset, -1 if table is full.
*/
int redirect_get_tableoffset(const char *funcname, 
                             const char *caller_libname,
                             const char *table_libname);


//! dlopens wrapper libraries.
/*! This internal function dlopens wrapper libraries pointed by LD_WRAP_LIB
    environmental variable with RTLD_LAZY and RTLD_GLOBAL flag. RTLD_LAZY is
    used to speed up loading process and RTLD_GLOBAL is used to export global
    symbols to resolve unresolved symbols in libraries opened later.
\return pointer to LD_WRAP_LIB environmental variable.
\sa specfile_read()
*/
char *wraplib_open(void);

//! Skips a line in given input file.
/*! Skips everything upto next newline character in file. File handle shoule be
    open and is not closed by the function even after EOF.
\param infile An open file handle. File handle is not closed.
\return EOF, if EOF is encountered. '\n' otherwise (if present)
*/
int skipline(FILE *infile);

//! Reads specification file and makes entries in LinkDef data structure.
/*! This function parses specificaiton file written in fixed format.
    It calls specfile_link_read() to read LINK specifications and
    specfile_table_read to read TABLE specifications.
\param linkdef Pointer to LinkDef data strcture to make entries in.
\param specfile_name Name of specification file.
\return Nothing
\sa specfile_link_read(), specfile_table_read(), skipline()
*/
void specfile_read(LinkDef *linkdef,const char *specfile_name);

//! Reads a LINK entry in specification file and makes entries in LinkDef data structure.
/*! This function parses specificaiton file for LINKs. It calls
    redirect_symtosym() for every LINK entry given in file.
\param linkdef Pointer to LinkDef data strcture to make entries in.
\param infile An open file handle. File handle is not closed.
\return EOF, if EOF is encountered.
\sa specfile_read(), specfile_table_read(), skipline()
*/
int specfile_link_read(LinkDef *linkdef,FILE *infile);

//! Reads a TABLE entry in specification file and makes entries in LinkDef data structure.
/*! This function parses a TABLE entry in specificaiton. It calls
    redirect_symtotable() for every entry in TABLE given in file.
\param linkdef Pointer to LinkDef data strcture to make entries in.
\param infile An open file handle. File handle is not closed.
\return EOF, if EOF is encountered.
\sa specfile_read(), specfile_link_read(), skipline()
*/
int specfile_table_read(LinkDef *linkdef,FILE *infile);

//! Deinitialises redirection library.
/*! This function is called automatically when program terminates.
    Redirection library 'unhooks' itself from Event Dispather and
    frees its entire LinkDef data structure.
\return Nothing.
*/
void _fini(void);

#endif


